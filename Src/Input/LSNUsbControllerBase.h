/**
 * Copyright L. Spiro 2023
 *
 * Written by: Shawn (L. Spiro) Wilcoxen
 *
 * Description: A base class for a USB controller.
 */


#pragma once

#include "../LSNLSpiroNes.h"
#include "../Event/LSNEvent.h"
#include "LSNControllerListener.h"

#include <thread>

namespace lsn {

	/**
	 * Class CUsbControllerBase
	 * \brief A base class for a USB controller.
	 *
	 * Description: A base class for a USB controller.
	 */
	class CUsbControllerBase {
	public :
		CUsbControllerBase();
		virtual ~CUsbControllerBase();


		// == Enumerations.
		/** The controller buttons. */
		enum LSN_BUTTONS {
			LSN_B_A,											/**< The A button. */
			LSN_B_B,											/**< The B button. */
			LSN_B_START,										/**< The Start button. */
			LSN_B_SELECT,										/**< The Select button. */
			LSN_B_UP,											/**< The Up button. */
			LSN_B_DOWN,											/**< The Down button. */
			LSN_B_LEFT,											/**< The Left button. */
			LSN_B_RIGHT,										/**< The Right button. */

			LSN_B_TOTAL,										/**< The total number of buttons on a controller (8). */
		};

		/** Input classes. */
		enum LSN_INPUT_CLASS {
			LSN_IC_AXIS,										/**< An axis. */
			LSN_IC_POV,											/**< A POV button. */
			LSN_IC_BUTTON,										/**< A standard button. */
		};


		// == Types.
		/** An input event. */
		struct LSN_INPUT_EVENT {
			size_t												stIdx;										/**< The index of the POV, button, or axis event. */
			LSN_INPUT_CLASS										icType;										/**< The type of input. */
			union {
				long											lAxis;										/**< The axis value if icType is LSN_IC_AXIS. */
				uint32_t										dwPov;										/**< The POV value if icType is LSN_IC_POV. */
				bool											bButton;									/**< The button value if icType is LSN_IC_BUTTON. */
			}													u;
		};

		/** A button map. */
		//struct LSN_BUTTON_MAP {
		//	/** The keyboard/controller button to map to the given input (by button index, LSN_BUTTONS) */
		//	uint16_t											ui16Map[LSN_B_TOTAL];
		//};


		// == Functions.
		/**
		 * Tells the controller to poll its device.  The polled data should not be inspected yet to determine which keys are held, it simply
		 *	tells the object to poll the controller for its data to then be gathered immediately after.
		 *
		 * \return Returns true if polling was successful.
		 */
		virtual bool											Poll() { return false; }

		/**
		 * Polls a button by its index.  Return true if the given button is pressed.
		 * 
		 * \param _ui8Idx The controller's button index to poll.
		 * \return Returns true if the button indexed by _ui8Idx is pressed, false otherwise.
		 **/
		virtual bool											PollButton( uint8_t /*_ui8Idx*/ ) const { return false; }

		/**
		 * Polls an axis by its index.  Axis 0 = X, 1 = Y, 2 = Z, and further indices are extra axes[IDX-2].
		 * 
		 * \param _ui8Idx The controller's axis index to poll.
		 * \return Returns the axis value at the given axis index.
		 **/
		virtual long											PollAxis( uint8_t /*_ui8Idx*/ ) const { return 0; }

		/**
		 * Gets the X-axis position.
		 * 
		 * \return Returns the controller's X axis value.
		 **/
		virtual long											AxisX() const { return PollAxis( 0 ); }

		/**
		 * Gets the Y-axis position.
		 * 
		 * \return Returns the controller's Y axis value.
		 **/
		virtual long											AxisY() const { return PollAxis( 1 ); }

		/**
		 * Gets the Z-axis position.
		 * 
		 * \return Returns the controller's Z axis value.
		 **/
		virtual long											AxisZ() const { return PollAxis( 2 ); }

		/**
		 * Gets a POV value given its POV index.
		 * 
		 * \param _ui8Idx The controller's POV index to poll.
		 * \return Returns the POV value given the POV array index.
		 **/
		virtual uint32_t										PollPov( uint8_t /*_ui8Idx*/ ) const { return 0; }

		/**
		 * Starts the thread.
		 * 
		 * \param _pclListener A pointer to an object that provides a listener interface for receiving notifications about controller events.
		 **/
		virtual void											BeginThread( CControllerListener * _pclListener = nullptr );

		/**
		 * Stops the thread.
		 **/
		virtual void											StopThread();

	protected :
		// == Types.
		/** The thread data. */
		struct LSN_THREAD {
			CUsbControllerBase *								m_pucbThis;					/**< A pointer to this class object. */
			CControllerListener *								m_pclListener;					/**< An optional pointer to an object that will listen for events generated by the thread. */
		};



		// == Members.
		/** The event-listening thread. */
		std::unique_ptr<std::thread>							m_ptThread;
		/** The thread event. */
		CEvent													m_eThreadClose;
		/** The event marking the closing of the thread. */
		CEvent													m_eThreadClosed;
		/** Thread data. */
		LSN_THREAD												m_tThreadData;
		/** Tells the thread to stop. */
		std::atomic<bool>										m_bStopThread;



		// == Functions.
		/**
		 * The thread function.
		 * 
		 * \param _ptThread A pointer to the thread data.
		 * \return Return true to keep the thread going, false to stop the thread.
		 **/
		virtual bool											ThreadFunc( LSN_THREAD * /*_ptThread*/ ) { return true; }

		/**
		 * The thread.
		 *
		 * \param _ptThread Pointer to this object.
		 */
		static void												Thread( LSN_THREAD * _ptThread );
	};

}	// namespace lsn
